<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<!-- Mirrored from docs.garagegames.com/tge/official/content/documentation/Engine/Reference/Render3D.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:22:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<HEAD><SCRIPT SRC="../../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/glossaryLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/referenceLookUp.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/componentContainer.html" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../../index.html";</SCRIPT><link href="../../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/referenceThemeStyle.html" rel="stylesheet" type="text/css" />
<link href="../../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 1116;
   parent.leftFrame.expandToItem('tree2', 'doc1116');
   var element = parent.leftFrame.document.getElementById('doc1116');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Torque: Torque: 3D Rendering</title>
<link href="torque.css" rel="stylesheet" type="text/css">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  bgcolor="#ffffff" text="#000000" link="#333399" alink="#9999ff" vlink="#000066">
<div align="center">

<table width=700 cellspacing=0 cellpadding=10 border=0 bgcolor="#ffffff" summary="">
<tr><td align='right'>
<a href='index.html'><img src="tge_banner.gif" alt="torque" align="left" border=0></a>
<b>Torque Game Engine Documentation</b><br>
<small>TGE Version 1.5.2</small>
</td></tr>

<tr><td>

<table width='100%' height=24 border=0 cellpadding=0 cellspacing=0>
<tr height=24><td nowrap class="menu" align='center'>

<a href="index.html">Torque Home</a> &nbsp;
<a href="hierarchy.html">Class Hierarchy</a> &nbsp;
<a href="annotated.html">Data Structures</a> &nbsp;
<!--a href="functions.php">Data Fields</a -->
<a href="namespaces.html">Namespaces</a> &nbsp;
<a href="namespacemembers.html">Namespace Members</a> &nbsp;
<a href="files.html">File List</a> &nbsp;
<a href="globals.html">Globals</a>

</td></tr>
</table>

</td></tr>
<tr><td>

<!-- Generated by Doxygen 1.5.2 -->
<h1><a class="anchor" name="Render3D"></a><a name = "HeaderLink0"></a>3D Rendering</h1><h2><a class="anchor" name="Render3DOver"></a><a name = "HeaderLink1"></a>Overview</h2>
Torque has a modular, extensible 3D world rendering system. Subclasses of the <a class="el" href="classGuiTSCtrl.html">GuiTSCtrl</a> override the <a class="el" href="classGuiTSCtrl.html#1bc5a6119518bd3b8ada650a0d51196d">GuiTSCtrl::processCameraQuery()</a> and <a class="el" href="classGuiTSCtrl.html#35d26856df28c5897a1bf3af945c1e4b">GuiTSCtrl::renderWorld()</a> methods to define the camera orientation/FOV, and draw the 3D scene using OpenGL drawing commands respectively. <a class="el" href="classGuiTSCtrl.html">GuiTSCtrl</a> manages setting up the viewport, modelview matrix and projection matrix. The Torque example code <a class="el" href="classGameTSCtrl.html">GameTSCtrl</a> class calls the global functions <a class="el" href="game_8h.html#37a1616ba3d7b085dd2493a9ca1eaaaf" title="Does the same thing as GameGetCameraTransform, but fills in other data including...">GameProcessCameraQuery()</a> and <a class="el" href="game_8h.html#ab7f4fd3e2f2d9ec5ab0b9f079346966" title="Actually renders the world. This is the function that will render the scene ONLY...">GameRenderWorld()</a>. <a class="el" href="game_8h.html#37a1616ba3d7b085dd2493a9ca1eaaaf" title="Does the same thing as GameGetCameraTransform, but fills in other data including...">GameProcessCameraQuery()</a> returns the viewing camera of the current control object (the object in the simulation that the player is currently controlling), then GameRenderWorld makes the client scene graph object render the world.<h2><a class="anchor" name="Render3DSceneGraph"></a><a name = "HeaderLink2"></a>SceneGraph</h2>
The scene graph library (engine/sceneGraph) is, on the client, responsible for traversing the world scene and determining which objects in the world should be rendered given the current camera position, and on the server, determines what objects should be sent to each client based on that client's position in the world.<p>
The world in the <a class="el" href="classSceneGraph.html">SceneGraph</a> is divided into zones - volumes of space bounded by solid areas and portals. The outside world is a single zone, while interior objects can have multiple interior zones. <a class="el" href="classSceneGraph.html#69749473a6501aee3ff80d498658415b">SceneGraph::findZone()</a> finds the zone of a given 3D point and reports which <a class="el" href="classSceneObject.html" title="A 3D object.">SceneObject</a> owns that zone. <a class="el" href="classSceneGraph.html#5659db276709f316a3dd6a21d92e1092">SceneGraph::rezoneObject()</a> determines which zone or zones contain a <a class="el" href="classSceneObject.html" title="A 3D object.">SceneObject</a> instance. At render time, the scene is traversed starting from the zone that contains the camera, clipping each zone's objects to the visible portal set from the zones before it. Scoping of network objects is performed in <a class="el" href="classSceneGraph.html#c391b0f455f25cd257ddf4265654cee1">SceneGraph::scopeScene()</a>.<p>
The scene graph traversal is complicated by transform portals. Transform portals are objects like mirrors or teleporters through which the world can be viewed using a different transform than the normal camera transform. When <a class="el" href="classSceneGraph.html#b815b807c6e57190ae48d742993e548f">SceneGraph::buildSceneTree()</a> encounters an object with a transform portal, it constructs a new <a class="el" href="classSceneState.html" title="The SceneState describes the state of the scene being rendered.">SceneState</a> object for rendering that portal's contents.<p>
Every renderable world object in the scene derives from the <a class="el" href="classSceneObject.html" title="A 3D object.">SceneObject</a> base class. As the world is traversed, visible objects are asked to prepare one or more <a class="el" href="classSceneRenderImage.html" title="A SceneRenderImage is used by the SceneState/SceneGraph to sort objects for rendering...">SceneRenderImage</a> objects (in <a class="el" href="classSceneObject.html#aebe52aeddafbba98e84b0ca4b4813cd" title="Called when the SceneGraph is ready for the registration of RenderImages.">SceneObject::prepRenderImage()</a>) that are then inserted into the current <a class="el" href="classSceneState.html" title="The SceneState describes the state of the scene being rendered.">SceneState</a> via <a class="el" href="classSceneState.html#e1797753f47ca637c1dc52fd1a15f9bc" title="Adds an image to be rendered by this SceneState into the proper category.">SceneState::insertRenderImage()</a>. Render images are sorted based on translucency and rendered from <a class="el" href="classSceneObject.html#80fef8cc5869d65085f073c1aff8dfe1" title="Called when the object is supposed to render itself.">SceneObject::renderObject()</a>. This system allows, for example, an interior object with multiple translucent windows to render the building first, followed by other objects, followed by the building's windows. Objects can insert any number of images for rendering.<h2><a class="anchor" name="Render3DTerrain"></a><a name = "HeaderLink3"></a>Terrain</h2>
The terrain library (engine/terrain) is the home for objects that render the outside world, including instances of the <a class="el" href="classSky.html">Sky</a>, <a class="el" href="classTerrainBlock.html">TerrainBlock</a> and <a class="el" href="classWaterBlock.html">WaterBlock</a> classes. The <a class="el" href="classSky.html">Sky</a> object renders the outside sky and cloud layers and maintains the visible distance and fog distance settings for the world. The sky also tracks vertical fog layers and installs them into the <a class="el" href="classSceneGraph.html">SceneGraph</a> for rendering.<p>
<a class="el" href="classTerrainBlock.html">TerrainBlock</a> manages a single 256x256 infinitely repeating block of heightfield terrain. Terrain heightfield data is stored and loaded using the <a class="el" href="classTerrainFile.html">TerrainFile</a> resource class (<a class="el" href="classResource.html">Resource&lt;TerrainFile&gt;</a>) so that a single terrain data file can be shared between server and client, when both are on the same execution instance. The <a class="el" href="structTerrainRender.html">TerrainRender</a> static class is used by <a class="el" href="classTerrainBlock.html">TerrainBlock</a> instances for rendering. The <a class="el" href="structTerrainRender.html#2db7e2db593eb3bae09fff1d7e0cb238">TerrainRender::renderBlock()</a> function renders the current repeating block of terrain.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There exists a TerrainManager resource which allows you to have NxM repeating areas of terrain, increasing the non-repeating terrain area.</dd></dl>
The terrain is textured by software blending base material textures into new material textures and then mapping those across 16 or more terrain squares based on the distance from the square. <a class="el" href="classBlender.html" title="This MODULE contains class Blender.">Blender</a> performs the blending of terrain textures and includes a MMX assembly version to speed the process (x86 architectures only).<p>
The <a class="el" href="classWaterBlock.html">WaterBlock</a> class manages a single block of water, which may or may not be infinitely repeating. Water is dynamically detailed based on distance, so nearby water is more highly tessellated. Though the surface of a water block is rectangular, the actual coverage of the water area can be set to seed fill from a point on the surface, allowing the water to fill a mountain crater, for example, without leaking outside the corner edges.<h2><a class="anchor" name="RenderInterior"></a><a name = "HeaderLink4"></a>Interior</h2>
The interior library (engine/interior) manages the rendering, collision and IO for interior objects. The <a class="el" href="classInteriorInstance.html">InteriorInstance</a> <a class="el" href="classSceneObject.html" title="A 3D object.">SceneObject</a> class manages a single interior. The <a class="el" href="classInteriorResource.html">InteriorResource</a> class manages the data associated with one definition of an interior, multiple instances of which may exist at any one time. Interiors manage zones for the scene graph, and may have subobjects that, for example, render a mirrored view (<a class="el" href="classMirrorSubObject.html">MirrorSubObject</a>). The <a class="el" href="classInteriorLMManager.html">InteriorLMManager</a> class manages lightmaps for all currently loaded interiors - sharing lightmaps among instances where possible.<p>
Interiors are converted to DIF by the tool Map2DIF (formerly known as Morian). The source files are just Quake-style .map files - lists of convex physical "brushes" that define the solid areas of the interior. Special brushes are used to define zone portal boundaries and objects such as doors and platforms.<h2><a class="anchor" name="Render3Space"></a><a name = "HeaderLink5"></a>3Space (TS)</h2>
The 3Space library (engine/ts) manages the display and animation of shape models in the world. The 3Space shape resource class <a class="el" href="classTSShape.html" title="TSShape stores generic data for a 3space model.">TSShape</a> can be shared between multiple <a class="el" href="classTSShapeInstance.html" title="An instance of a 3space shape.">TSShapeInstance</a> instances. The <a class="el" href="classTSShape.html" title="TSShape stores generic data for a 3space model.">TSShape</a> class manages all the static data for a shape - mesh data, animation keyframes, material lists, decal information, triggers and detail levels (for dynamically detailed shapes).<p>
The <a class="el" href="classTSShapeInstance.html" title="An instance of a 3space shape.">TSShapeInstance</a> class manages animation, rendering and detail selection for an instance of a shape. The <a class="el" href="classTSShapeInstance.html" title="An instance of a 3space shape.">TSShapeInstance</a> class uses the <a class="el" href="classTSThread.html" title="3space animation thread.">TSThread</a> class to manage one of the concurrently running animations on an instance. <a class="el" href="classTSShapeInstance.html#44f5c1fadbd5b7e13b514297084d3751" title="Create a new thread.">TSShapeInstance::addThread()</a> initializes a new thread on a shape instance, and <a class="el" href="classTSShapeInstance.html#ff6ad5641350d1d5b392b9463b65e2de" title="Get the thread a sequence.">TSShapeInstance::setSequence()</a> sets an animation sequence for a given thread. Each thread can be individually advanced in time, or can be set on a time scale that is used when all threads are advanced in <a class="el" href="classTSShapeInstance.html#cf0bbb9201cb516390d2e4aeb350ed71" title="advance time on a particular thread">TSShapeInstance::advanceTime()</a>. A thread can also manage transitions between sequences with <a class="el" href="classTSShapeInstance.html#6f6feeb2aaa522dae256df2917256f98" title="Transition to a sequence.">TSShapeInstance::transitionToSequence()</a>.<p>
<a class="el" href="classTSShape.html" title="TSShape stores generic data for a 3space model.">TSShape</a> animation sequences can be composed of node/bone animation (for example, joints in an explosion), material animation (a texture animation on an explosion) and mesh animation (a morphing blob - note most mesh animations can be accomplished with node scale and rotation animations). Animations can also contain visibility tracks so that some meshes in the shape are not visible until an animation is played.   </td>
</tr>
</table>

<br>
<br>
<hr width='50%' height=1 color=black>
<b>All Rights Reserved GarageGames.com, Inc. 1999-2005</b><br>
<small>Auto-magically Generated with <a href='http://www.doxygen.org/' target='_blank'>Doxygen</a></small>

</div>
<div class="footer">   <span class="copy">&copy; <a href="http://www.garagegames.com/">GarageGames.com</a></span>   <a href="../../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>

<!-- Mirrored from docs.garagegames.com/tge/official/content/documentation/Engine/Reference/Render3D.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 06 Dec 2017 21:22:25 GMT -->
</html>
